import numpy as np
from typing import Callable, List, Any, Optional

class TargetDistribution:
    """
    Base class for target distributions that can be used with both Metropolis and HMC.
    At minimum, must implement __call__ for density evaluation.
    Optionally can implement log_density and grad_log_density for HMC.
    """
    def __call__(self, x: np.ndarray) -> float:
        """Evaluate the probability density function at x."""
        raise NotImplementedError
        
    def log_density(self, x: np.ndarray) -> Optional[float]:
        """Log of the probability density function. Optional for HMC."""
        return np.log(self(x))
        
    def grad_log_density(self, x: np.ndarray) -> Optional[np.ndarray]:
        """Gradient of the log probability density function. Optional for HMC."""
        return None

class HMCSampler:
    """Hamiltonian Monte Carlo sampler."""
    
    def __init__(
        self,
        target: TargetDistribution,
        initial: Callable[[], np.ndarray],
        iterations: int = 10_000,
        L: int = 50,
        step_size: float = 0.1
    ):
        """
        Initialize the HMC sampler.
        
        Args:
            target: Target distribution implementing at least __call__.
                   For HMC, should also implement log_density and grad_log_density.
            initial: Function that returns initial position
            iterations: Number of iterations to run
            L: Number of leapfrog steps
            step_size: Size of each leapfrog step
        """
        self.target = target
        self.initial = initial
        self.iterations = iterations
        self.L = L
        self.step_size = step_size
        self.samples = []
        
        # Check if target has required methods for HMC
        if not hasattr(target, 'grad_log_density') or target.grad_log_density(None) is None:
            raise ValueError("Target distribution must implement grad_log_density for HMC")
        
    def _leapfrog(
        self,
        q0: np.ndarray,
        p0: np.ndarray
    ) -> tuple[np.ndarray, np.ndarray]:
        """
        Leapfrog integrator for Hamiltonian dynamics.
        
        Args:
            q0: Initial position
            p0: Initial momentum
            
        Returns:
            Final position and momentum after L steps
        """
        q = q0.copy()
        p = p0.copy()
        
        # Half step for momentum
        p += self.target.grad_log_density(q) * self.step_size / 2
        
        for _ in range(self.L):
            # Full step for position
            q += p * self.step_size
            
            # Full step for momentum (except last step)
            if _ < self.L - 1:
                p += self.target.grad_log_density(q) * self.step_size
        
        # Final half step for momentum
        p += self.target.grad_log_density(q) * self.step_size / 2
        
        return q, p
    
    def run(self) -> List[np.ndarray]:
        """
        Run the HMC algorithm and return samples.
        References: https://www.tcbegley.com/blog/posts/mcmc-part-2
        
        Returns:
            List of samples from the target distribution
        """
        self.samples = [self.initial()]
        
        for _ in range(self.iterations):
            q0 = self.samples[-1]
            # Sample momentum from standard normal
            p0 = np.random.standard_normal(size=q0.shape)
            
            # Generate proposal using leapfrog integration
            qL, pL = self._leapfrog(q0, p0)
            
            # Calculate Hamiltonian at start and end
            h0 = -self.target.log_density(q0) + (p0 * p0).sum() / 2
            hL = -self.target.log_density(qL) + (pL * pL).sum() / 2
            
            # Calculate acceptance ratio
            log_accept_ratio = h0 - hL
            
            # Accept or reject
            if np.random.random() < np.exp(log_accept_ratio):
                self.samples.append(qL)
            else:
                self.samples.append(q0)
                
        return self.samples
    
    def get_samples(self) -> List[np.ndarray]:
        """Get the samples generated by the sampler."""
        return self.samples 